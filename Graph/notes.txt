Defination:
A Graph is an ordered pair of G = (V, E) comprising a set V of vertices or nodes together with a set E of edges or arcs, which are 2-element subsets of V (i.e. an edge is associated with two vertices, and that association takes the form of the unordered pair comprising those two vertices)

Graph types:

Undirected Graph: a graph in which the adjacency relation is symmetric. So if there exists an edge from node u to node v (u -> v), then it is also the case that there exists an edge from node v to node u (v -> u)

Directed Graph: a graph in which the adjacency relation is not symmetric. So if there exists an edge from node u to node v (u -> v), this does not imply that there exists an edge from node v to node u (v -> u)

Uses:
Graphs are used to represent networks. The networks may include paths in a city or telephone network or circuit network. Graphs are also used in social networks like linkedIn, Facebook. For example, in Facebook, each person is represented with a vertex(or node). Each node is a structure and contains information like person id, name, gender, locale etc

Graph representations:
1. Adjacency Matrix
Pros:
Removing an edge takes O(1) time. Query to check if there is an edges takes O(1) time.
Cons:
Consumes more space O(V^2) even if graph is spare. Adding a vertex is O(V^2) time.
2. Adjacency List
Pros:
Save space O(|V|+|E|). Adding a vertex is easier.
Cons:
Queries like whether there is an edge from vertex u to vertex v are not efficient and can be done O(V).

Applications of DFS:
1.For a weighted graph, DFS traversal of the graph produces the minimum spanning tree and all pair shortest path tree.
2.Detect cycle in graph.
3.Path Finding
4.Topological sorting
5.To test if a graph is bipartite
6.Finding strongly connected components of graph

Applications of BFS:
1.Shortest Path and Minimum Spanning Tree for unweighted graph
2.Peer to peer network like BitTorrent
3.Crawlers in search engines
4.Social network websites
5.GPS navigation systems
6.Broadcast in network
7.In garbage collection
8.Cycle detection in undirected graph
9.Ford-Fulkerson algorithm
10.To test if a graph is bipartite
11.Path finding
12.Finding all nodes within one connected component